# Adattípusok, adatszerkezetek

Az R programozásának megértéséhez szükséges egyik alapelemünk a változó: változóban tudunk információt tárolni, legyen az egyetlen szám vagy egy egész adatbázis, vagy akár egy regressziós modell. Változóból tetszőleges számút létrehozhatunk.

Változó értéket az értékadás művelettel kap; ez kb. a ,,legyen egyenlő'' módon olvasható ki. Az R-ben nem kell előre megmondanunk, hogy milyen változókra van szükségünk: ha egy eddig még nem létező változónak adunk értéket, akkor az R automatikusan létrehozza. (Majd természetesen az értékét is beállítja arra, amit megadtunk.) Már létező változónak történő értékadásnál az előző érték elveszlik, és felülíródik az aktuálisan megadottal.

Az a tény, hogy az R - nagyon sok más programnyelvvel szemben! - megengedi ezt, tehát, hogy nem létező változónak is adhatunk értéket, és ilyenkor azt ő automatikusan, a háttérben, anélkül, hogy bármit szólna, létrehozza, egy jó példa az R általános filozófiájára, ami sok helyen előjön. Jelesül: az R szintaktikailag flexibilis, ,,megengedi trehányságot'' -- ami viszont kétélű fegyver! Egyfelől ugyanis nagyon kényelmes, jelen esetben, hogy nem kell törődnünk a változók előzetes deklarálásával, de másrészt így könnyebben előfordulhat, hogy olyat csinálunk, amit igazából nem szeretnénk -- csak épp észre sem vesszük! Elírjuk a változó nevét, és nem figyelmeztetést kapunk, hogy de hát ilyen változó nem létezik, hanem egyetlen hang nélkül létrejön egy új, hibás nevű (miközben az igazi értéke marad változatlan). És ez talán még a legkevésbé éles példa.

## Adattípusok, változó, értékadás

Az értékedás jele az R-ben a `<-`. (Az `=`-t ne használjuk értékadásra, csak függvényben az argumentum értékének megadására!).

Az `str` általában a legjobb leírója egy objektumnak. A `typeof` az objektum típusát adja meg.

Az R-ben 4 fontos adattípus van (type, mode).

Numerikus, alapból double:

```{r}
szam <- 3.1
szam
str( szam )
typeof( szam )
```

Nézzük meg, hogy csakugyan case sensitive a nyelv:
```{r, error=TRUE}
SZAM
Szam
```

Attól mert valami történetesen egész, még double pontosságú lesz:
```{r}
szam <- 3
str( szam )
typeof( szam )
```

A double pontossága jellemzően 53 bit (kb. $-2\cdot 10^{308}$-tól $2\cdot 10^{308}$-ig nagyjából $2\cdot 10^{-16}$ felbontással; az adott architektúra vonatkozó értéket a `.Machine` megmondja).

Ha egészet (integer) akarunk, azt külön kell jelölni az `L` utótaggal:
```{r}
egesz <- 3L
egesz
str( egesz )
typeof( egesz )
```

A numeric a mode, a double/integer a type. A többi adattípusnál a mode és a type egybeesik.

Karakter:
```{r}
szoveg <- "kiskutya"
szoveg
str( szoveg )
typeof( szoveg )
```

Mint látható, a sztringkonstansokat idézőjellel kell jelölni. Az R megengedi a dupla (`" "`) és a szimpla (`' '`) idézőjel használatát is, de az előbbi a preferált (az R általi kiírás is mindenképp ilyennel történik), az utóbbit érdemes az egymásbaágyazott esetekre használni (tehát, ha egy sztringkonstans tartalmaz egy idézőjeles részt).

Logikai:
```{r}
logikai <- TRUE
logikai
str( logikai )
typeof( logikai )
```

A `TRUE` rövidíthető `T`-nek, a `FALSE` pedig `F`-nek.

Adott típus tesztelése az `is.<tipus>` alakban lehet:
```{r}
is.integer( szam )
is.integer( egesz )
is.integer( szoveg )
is.integer( logikai )
```

Az `is.numeric` azt jelenti, hogy `is.integer` vagy `is.double`:
```{r}
is.double( szam )
is.double( egesz )
is.numeric( szam )
is.numeric( egesz )
```

Elvileg még két adattípus van, a `raw` és a `complex`, nem olyan fontosak. Van olyan dolog - például faktor - ami adattípusnak tűnik, de mégsem az (egy másik típus speciális esete).

Adott típussá alakítás `as.<tipus>` alakban lehet:
```{r}
as.character( szam )
as.numeric( szoveg )
as.numeric( "2.4" )
as.numeric( logikai )
```

Konvertálásnál az ,,erősorrend'': character < double = integer < logical (a `T` 1-re, a `F` 0-ra alakul, a többi értelemszerű). Az ezt sértő dolgok NA-t adnak. Sok parancs automatikusan konvertál!

Hiányzó értéket `NA` jelöli (adott típusú hiányzó adat `NA_real_`, `NA_integer_` és `NA_character_` módokon kérhető).

Speciális szerepe van még a `NULL`-nak (ez inkább olyasmit jelöl, hogy ,,üres objektum''), illetve az `NaN`-nek (not-a-number, tipikusan olyan adja, mint például ha negatív szám logaritmusát vesszük).

## Adatszerkezetek és indexelés

### Vektor

A vektor homogén, 1 dimenziós adatszerkezet.

Legegyszerűbb módon az elemei felsorolásával hozható létre, ehhez a `c` függvény használható:
```{r}
szamvektor <- c( 1, 4, 5, -2, 3, 10 )
szamvektor
typeof( szamvektor )
length( szamvektor )
```

Az `[1]` a sor elején nem része a vektornak, az olvashatóságot segíti, amint azt a következő példa mutatja (a `:` egész számokból generál sorozatot):
```{r}
1:100
```

Skalár nincs az R-ben, ami annak tűnik, az igazából 1 elemű vektor:
```{r}
typeof( szam )
length( szam )
```

Természetesen nem csak numerikus adatokból képezhető vektor, hanem bármilyenből:

```{r}
karaktervektor <- c( "a", "b", "xyz" )
karaktervektor
typeof( karaktervektor )
length( karaktervektor )

```

A vektor homogén, az alábbi utasítások csak azért futnak le mégis, mert a háttérben ilyenkor az R a ,,leggyengébbre'' konvertálja az összeset (hogy kikényszerítse a homogenitást):
```{r}
c( 1, "a" )
c( 2, TRUE )
```

A vektor elemei el is nevezhetőek; a nevek később a `names`-zel lekérhetőek, és át is állíthatóak:
```{r}
szamvektor <- c( elso = 4, masodik = 1, harmadik = 7 )
szamvektor
names( szamvektor )
names( szamvektor )[ 3 ] <- "utolso"
szamvektor
```

Látható, hogy a `names` ,,kétirányú``: szolgáltat nekünk adatokat, de bele is nyilazhatunk értéket, ez utóbbi esetben beállítja.

A indexelés lehet számmal vagy vektorral (ugye igazából ugyanaz!), adott pozició vagy pozíciók kiválaszthatóak:
```{r}
szamvektor[ 3 ]
szamvektor[ c( 1, 3 ) ]
```

Egy elem kiválasztható többször is:
```{r}
szamvektor[ c( 2, 2 ) ]
```

Kiválasztható az összes elem is, ekkor lényegében csak a sorrendet módosítjuk (az `order` megadja, hogy az adott elem hányadik a nagyság szerinti sorrendben):
```{r}
szamvektor[ c( 3, 2, 1, 4, 5, 6 ) ]
szamvektor[ order( szamvektor ) ]
```

Nemlétező elem indexelése `NA`-t ad:
```{r}
szamvektor[ 10 ]
```

Lehetséges negatív indexelés is, ez kiválaszt mindent, _kivéve_ amit indexeltünk:
```{r}
szamvektor[ -3 ]
szamvektor[ -c( 1, 3 ) ]
```

Indexelhetünk logikai tömbbel is, ugyanolyan hosszú kell legyen mint az eredeti, és azokat választja ki, ahol `T` van:
```{r}
szamvektor[ c( T, F, T, T, F, T ) ]
```
Rövidebb tömbbel indexelés csak azért fog működik, mert ilyenkor az R reciklálja az indexelő vektort. (Ez általában is így van: újabb példa a kétélű flexibilitásra.)

Ha vannak elnevezések, akkor azok használhatóak indexelésre is:
```{r}
szamvektor[ "masodik" ]
szamvektor[ c( "masodik", "utolso" ) ]
```

Az indexelés és az értékadás kombinálható is:
```{r}
szamvektor[ 3 ] <- 99
szamvektor
szamvektor[ 10 ]
```

Ha nemlétezőnek adunk értéket, automatikusan kiterjeszti a vektort, a többi helyre pedig `NA` kerül (megint újabb példa a kétélű flexibilitásra):
```{r}
szamvektor[ 10 ] <- 999
szamvektor
```

### Mátrix

A mátrix homogén, kétdimenziós adatszerkezet.

Legegyszerűbben úgy tölthető fel, ha egy vektort áttördelünk, a `matrix` függvény használatával (az `nc` argumentummal az oszlopok, az `nr` argumentummal a sorok számát állíthatjuk be, értelemszerűen elég a kettőből egyet megadni):
```{r}
szammatrix <- matrix( 1:6, nc = 2 )
szammatrix
```

Alapból oszlopok szerint tölt, de a `byrow` argumentummal ezt átállíthatjuk:
```{r}
matrix( 1:6, nc = 2, byrow = TRUE )
```

A dimenzió, illetve külön a sorok és oszlopok száma könnyen lekérhető:
```{r}
dim( szammatrix )
nrow( szammatrix )
ncol( szammatrix )
```

A mátrix oszlopai és sorai is elnevezhetőek, emiatt itt nem egy `names` van, hanem egy `row.names` és egy `names`, ez utóbbi az oszlopnév, de egyebekben teljesen hasonlóan viselkednek.

Indexelés ugyanúgy végezhető, csak épp mindkét dimenzióra mondanunk kell valamit; a kettő vesszővel választandó el:
```{r}
szammatrix[ c( 2, 3 ), 2 ]
```

Mindkét dimenzió tetszőleges korábban látott módon indexelhető, tehát a különböző módok keverhetőek is:
```{r}
szammatrix[ c( 1, 2 ), c( T, F ) ]
```

Ha egy dimenziót nem indexelünk, akkor az R úgy érti, hogy onnan minden elem (de a vessző ekkor sem hagyható el!):
```{r}
szammatrix[ 2, ]
```

### Tömb (array)

A tömb (array) homogén, $n$-dimenziós adatszerkezet (nem foglalkozunk vele részletesebben, ritkán használatos).

### Data frame

A data frame (adatkeret) heterogén, kétdimenziós, rektanguláris adatszerkezet. Pontosabban szólva félig heterogén: az oszlopok homogének, de a különböző oszlopok típusai eltérhetnek egymástól. Lényegében tehát - nem feltétlenül ugyanolyan típusú - vektorok összefogva; a rektanguláris azt jelenti, hogy minden vektor ugyanolyan hosszú kell legyen.

Ez a legtipikusabb adatszerkezet orvosi adatok tárolására: sorokban a megfigyelési egységek, oszlopokban a változók.

A `data` paranccsal egy kiegészítő csomagban található kész adat tölthető be:

```{r}
data( birthwt, package = "MASS" )
birthwt
```

Csak a felső néhány sor a `head` paranccsal kérhető le (az alsó néhány sor pedig a `tail`-lel):
```{r}
head( birthwt )
```

Az oszlopok és a sorok is elnevezhetőek:
```{r}
str( birthwt )
names( birthwt )
colnames( birthwt )
```

Az adatkeret a mátrixhoz hasonlóan indexelhető:
```{r}
birthwt[ 3, ]
birthwt[ 3, 4 ]
birthwt[ 3, c( 5, 6 ) ]
```

Sőt, ha vannak elnevezéseink, az is használható. A következő 4 mind egyenértékű:
```{r}
birthwt[ , 10  ]
birthwt$bwt
birthwt[ , "bwt" ]
birthwt[[ "bwt" ]]
```

A nem dupla szögletes zárójellel történő indexelés eltérése, hogy nem a kiválasztott vektort, hanem egy csak a kiválasztott vektorból álló data frame-et ad vissza:
```{r}
birthwt[[ "bwt" ]]
str( birthwt[[ "bwt" ]] )
head( birthwt[ "bwt" ] )
str( birthwt[ "bwt" ] )
```

Használhatunk különféle módszereket (az alábbiak közül a második a logikai indexelés miatt fog működni):
```{r}
head( birthwt[ , c( "lwt", "smoke" ) ] )
head( birthwt[ birthwt$smoke==1, ] )
head( birthwt[ birthwt$smoke==1&birthwt$race==1, ] )
```

Az adatkeret heterogén:
```{r}
birthwt$nev <- "a"
head( birthwt )
str( birthwt )
```

### Lista

A lista heterogén, egydimenziós adatszerkezet.

Legegyszerűbben elemei felsorolásával hozható létre, a `list` függvényt használva:
```{r}
lista <- list( sz = szamvektor, k = karaktervektor, m = szammatrix, df = birthwt[ 1:5, ] )
lista
str( lista )
```

Számmal és -- ha van neki -- névvel is indexelhető:
```{r}
lista[[ 1 ]]
lista$sz
lista[[ "sz" ]]

```

Az egy zárójellel történő indexelés látszólag ugyanaz, de csak látszólag:
```{r}
lista[ 1 ]
typeof( lista[[ 1 ]] )
typeof( lista[ 1 ] )
```

Tartomány is indexelhető:
```{r}
lista[ 1:2 ]
lista[[ 1:2 ]]
```

Az előbbi dolgok természetesen kombinálhatóak is:
```{r}
idx <- "sz"
lista[[ idx ]]
```

Az adatkeret igazából egy, az oszlopokból - mint vektorokból - összerakott lista (tehát két szűkítés van: az elemek csak vektorok lehetnek _és_ ugyanolyan hosszúaknak kell lenniük).
